"use server";

import {
  AVATAR_UPLOAD_MAX_BYTES,
  compressImageForAvatar,
} from "@/lib/avatar-upload";
import { createClient } from "@/lib/supabase/server";
import { normalizeLinkedInProfileUrl } from "@/lib/utils";
import { revalidatePath } from "next/cache";
import { AFFILIATE_FORM_FIELD } from "@/lib/affiliate";

const AFFILIATE_SOURCE_LANDING_REF = "landing_ref";

const AVATAR_ALLOWED_TYPES = [
  "image/jpeg",
  "image/png",
  "image/webp",
  "image/gif",
];

async function uploadAvatarForUser(
  supabase: Awaited<ReturnType<typeof createClient>>,
  userId: string,
  file: File,
): Promise<string | null> {
  if (file.size > AVATAR_UPLOAD_MAX_BYTES) return null;
  if (!AVATAR_ALLOWED_TYPES.includes(file.type)) return null;

  const path = `${userId}/avatar-${Date.now()}.jpg`;
  const arrayBuffer = await file.arrayBuffer();
  const buffer = Buffer.from(arrayBuffer);
  const compressed = await compressImageForAvatar(buffer);

  const { error } = await supabase.storage
    .from("avatars")
    .upload(path, compressed, {
      contentType: "image/jpeg",
      cacheControl: "3600",
      upsert: true,
    });

  if (error) return null;

  const {
    data: { publicUrl },
  } = supabase.storage.from("avatars").getPublicUrl(path);

  return publicUrl;
}

export async function completeSaasOnboarding(formData: FormData) {
  const supabase = await createClient();

  const {
    data: { user },
  } = await supabase.auth.getUser();
  if (!user) {
    return { error: "Non authentifié" };
  }

  const companyName = formData.get("companyName") as string;
  const description = formData.get("description") as string;
  const website = formData.get("website") as string;
  const industry = formData.get("industry") as string;
  const mediaPackUrl = formData.get("mediaPackUrl") as string | null;
  const country = formData.get("country") as string;
  const vatNumber = formData.get("vatNumber") as string | null;
  const isVatRegistered = formData.get("isVatRegistered") === "on";
  const avatarFile = formData.get("avatar") as File | null;
  const rawAffiliate = (formData.get(AFFILIATE_FORM_FIELD) as string)?.trim();
  const affiliateCode =
    rawAffiliate && rawAffiliate.length > 0 ? rawAffiliate.toUpperCase() : null;

  let avatarUrl: string | null = null;
  if (avatarFile && avatarFile.size > 0) {
    const uploadedUrl = await uploadAvatarForUser(
      supabase,
      user.id,
      avatarFile,
    );
    if (uploadedUrl) {
      avatarUrl = uploadedUrl;
    }
  }

  // Check if company already exists (and current affiliate_code for no-overwrite rule)
  const { data: existingCompany } = await supabase
    .from("saas_companies")
    .select("id, affiliate_code")
    .eq("profile_id", user.id)
    .single();

  const nowIso = new Date().toISOString();
  let saasAffiliatePayload: {
    affiliate_code?: string;
    affiliate_attributed_at?: string;
    affiliate_source?: string;
  } = {};
  if (affiliateCode) {
    const { data: codeRow } = await supabase
      .from("affiliate_codes")
      .select("code")
      .eq("code", affiliateCode)
      .maybeSingle();
    const maySetAffiliate =
      !existingCompany || existingCompany.affiliate_code === null;
    if (codeRow && maySetAffiliate) {
      saasAffiliatePayload = {
        affiliate_code: affiliateCode,
        affiliate_attributed_at: nowIso,
        affiliate_source: AFFILIATE_SOURCE_LANDING_REF,
      };
    }
  }

  if (existingCompany) {
    // Update existing company (only set affiliate if currently NULL)
    const { error } = await supabase
      .from("saas_companies")
      .update({
        company_name: companyName,
        description,
        website,
        industry,
        media_pack_url: mediaPackUrl,
        country: country || null,
        vat_number: vatNumber || null,
        is_vat_registered: isVatRegistered,
        ...saasAffiliatePayload,
      })
      .eq("profile_id", user.id);

    if (error) {
      return { error: error.message };
    }
  } else {
    // Create new company
    // Note: API key will be auto-generated by database trigger
    const { error } = await supabase.from("saas_companies").insert({
      profile_id: user.id,
      company_name: companyName,
      description,
      website,
      industry,
      media_pack_url: mediaPackUrl,
      country: country || null,
      vat_number: vatNumber || null,
      is_vat_registered: isVatRegistered,
      ...saasAffiliatePayload,
    });

    if (error) {
      return { error: error.message };
    }
  }

  // Mark onboarding as completed & optionally store avatar
  const profileUpdate: Record<string, unknown> = {
    onboarding_completed: true,
  };
  if (avatarUrl) {
    profileUpdate.avatar_url = avatarUrl;
  }

  const { error: profileError } = await supabase
    .from("profiles")
    .update(profileUpdate)
    .eq("id", user.id);

  if (profileError) {
    return { error: profileError.message };
  }

  revalidatePath("/dashboard");
  return { success: true };
}

export async function completeCreatorOnboarding(formData: FormData) {
  const supabase = await createClient();

  const {
    data: { user },
  } = await supabase.auth.getUser();
  if (!user) {
    return { error: "Non authentifié" };
  }

  const legalStatus = formData.get("legalStatus") as
    | "particulier"
    | "professionnel";
  const firstName = formData.get("firstName") as string;
  const lastName = formData.get("lastName") as string;
  const dateOfBirth = formData.get("dateOfBirth") as string;
  const streetAddress = formData.get("streetAddress") as string;
  const postalCode = formData.get("postalCode") as string;
  const city = formData.get("city") as string;
  const country = formData.get("country") as string;
  const linkedinUrl = normalizeLinkedInProfileUrl(
    formData.get("linkedinUrl") as string,
  );
  const followersCountRaw = formData.get("followersCount") as string | null;
  const followersCount =
    followersCountRaw && followersCountRaw.trim() !== ""
      ? Number.parseInt(followersCountRaw, 10) || 0
      : 0;
  const themesFromForm = formData.getAll("themes") as string[] | null;
  const cleanedThemes =
    themesFromForm
      ?.map((t) => (t || "").toString().trim())
      .filter((t) => t.length > 0) || [];
  const theme =
    (formData.get("theme") as string | null) || cleanedThemes[0] || null;
  const bio = formData.get("bio") as string | null;
  const recentPostsLinkedin = formData.get("recentPostsLinkedin") as
    | string
    | null;
  const companyLegalName = formData.get("companyLegalName") as string | null;
  const companyRegistrationCountry = formData.get(
    "companyRegistrationCountry",
  ) as string | null;
  const companyTaxId = formData.get("companyTaxId") as string | null;
  const companyVatNumber = formData.get("companyVatNumber") as string | null;
  const companyRegisteredAddress = formData.get("companyRegisteredAddress") as
    | string
    | null;
  const avatarFile = formData.get("avatar") as File | null;
  const rawAffiliateCreator = (formData.get(AFFILIATE_FORM_FIELD) as string)
    ?.trim();
  const affiliateCodeCreator =
    rawAffiliateCreator && rawAffiliateCreator.length > 0
      ? rawAffiliateCreator.toUpperCase()
      : null;

  if (legalStatus === "professionnel") {
    if (
      !companyLegalName ||
      !companyRegistrationCountry ||
      !companyTaxId ||
      !companyRegisteredAddress
    ) {
      return {
        error:
          "Informations d'entreprise manquantes. Merci de compléter tous les champs obligatoires.",
      };
    }
  }

  const updateData: Record<string, unknown> = {
    first_name: firstName,
    last_name: lastName,
    date_of_birth: dateOfBirth || null,
    street_address: streetAddress,
    postal_code: postalCode,
    city,
    country,
    linkedin_url: linkedinUrl,
    followers_count: followersCount,
    theme: theme || null,
    expertise_sectors:
      cleanedThemes.length > 0 ? cleanedThemes.slice(0, 3) : null,
    bio: bio || null,
    legal_status: legalStatus || "particulier",
    mandate_accepted_at: new Date().toISOString(),
  };

  if (legalStatus === "professionnel") {
    if (companyLegalName) {
      updateData.company_legal_name = companyLegalName;
    }
    if (companyRegistrationCountry) {
      updateData.company_registration_country = companyRegistrationCountry;
    }
    if (companyTaxId) {
      updateData.company_tax_id = companyTaxId;

      // For French companies, also map to legacy siret_number for compatibility
      if (companyRegistrationCountry === "FR") {
        const normalizedSiret = companyTaxId.replace(/\s+/g, "");
        updateData.siret_number = normalizedSiret;
      }
    }
    if (companyVatNumber) {
      updateData.company_vat_number = companyVatNumber;
    }
    if (companyRegisteredAddress) {
      updateData.company_registered_address = companyRegisteredAddress;
    }
  }

  if (recentPostsLinkedin) {
    updateData.recent_posts_linkedin = recentPostsLinkedin;
  }

  let avatarUrl: string | null = null;
  if (avatarFile && avatarFile.size > 0) {
    const uploadedUrl = await uploadAvatarForUser(
      supabase,
      user.id,
      avatarFile,
    );
    if (uploadedUrl) {
      avatarUrl = uploadedUrl;
    }
  }

  // Check if creator profile already exists (and affiliate_code for no-overwrite rule)
  const { data: existingProfile } = await supabase
    .from("creator_profiles")
    .select("id, affiliate_code")
    .eq("profile_id", user.id)
    .single();

  const nowIsoCreator = new Date().toISOString();
  let creatorAffiliatePayload: Record<string, unknown> = {};
  if (affiliateCodeCreator) {
    const { data: codeRowCreator } = await supabase
      .from("affiliate_codes")
      .select("code")
      .eq("code", affiliateCodeCreator)
      .maybeSingle();
    const maySetAffiliateCreator =
      !existingProfile || existingProfile.affiliate_code === null;
    if (codeRowCreator && maySetAffiliateCreator) {
      creatorAffiliatePayload = {
        affiliate_code: affiliateCodeCreator,
        affiliate_attributed_at: nowIsoCreator,
        affiliate_source: AFFILIATE_SOURCE_LANDING_REF,
      };
    }
  }

  if (existingProfile) {
    const { error } = await supabase
      .from("creator_profiles")
      .update({ ...updateData, ...creatorAffiliatePayload })
      .eq("profile_id", user.id);

    if (error) {
      return { error: error.message };
    }
  } else {
    const { error } = await supabase.from("creator_profiles").insert({
      profile_id: user.id,
      ...updateData,
      ...creatorAffiliatePayload,
    });

    if (error) {
      return { error: error.message };
    }
  }

  // Update profiles full_name, optional avatar & mark onboarding as completed
  const fullName = [firstName, lastName].filter(Boolean).join(" ");
  const profileUpdate: Record<string, unknown> = {
    onboarding_completed: true,
  };
  if (fullName) {
    profileUpdate.full_name = fullName;
  }
  if (avatarUrl) {
    profileUpdate.avatar_url = avatarUrl;
  }

  const { error: profileError } = await supabase
    .from("profiles")
    .update(profileUpdate)
    .eq("id", user.id);

  if (profileError) {
    return { error: profileError.message };
  }

  revalidatePath("/dashboard");
  return { success: true };
}

export async function uploadMediaPack(formData: FormData) {
  const supabase = await createClient();

  const {
    data: { user },
  } = await supabase.auth.getUser();
  if (!user) {
    return { error: "Non authentifié", url: null };
  }

  const file = formData.get("file") as File;
  if (!file) {
    return { error: "Aucun fichier fourni", url: null };
  }

  const fileExt = file.name.split(".").pop();
  const fileName = `${user.id}/media-pack-${Date.now()}.${fileExt}`;

  const { error, data } = await supabase.storage
    .from("media-packs")
    .upload(fileName, file, {
      cacheControl: "3600",
      upsert: true,
    });

  if (error) {
    return { error: error.message, url: null };
  }

  const {
    data: { publicUrl },
  } = supabase.storage.from("media-packs").getPublicUrl(fileName);

  return { success: true, url: publicUrl };
}

export async function getCurrentUserProfile() {
  const supabase = await createClient();

  const {
    data: { user },
  } = await supabase.auth.getUser();
  if (!user) {
    return null;
  }

  const { data: profile } = await supabase
    .from("profiles")
    .select("*")
    .eq("id", user.id)
    .single();

  return profile;
}

export async function signOut() {
  const supabase = await createClient();

  // Sign out from Supabase (clears session)
  await supabase.auth.signOut({ scope: "local" });

  // Return success - client will handle redirect
  return { success: true };
}
