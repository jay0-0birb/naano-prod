"use server";

import { createClient } from "@/lib/supabase/server";
import { normalizeLinkedInProfileUrl } from "@/lib/utils";
import { revalidatePath } from "next/cache";

const AVATAR_MAX_SIZE = 2 * 1024 * 1024; // 2MB
const AVATAR_ALLOWED_TYPES = [
  "image/jpeg",
  "image/png",
  "image/webp",
  "image/gif",
];

async function uploadAvatarForUser(
  supabase: Awaited<ReturnType<typeof createClient>>,
  userId: string,
  file: File,
): Promise<string | null> {
  if (file.size > AVATAR_MAX_SIZE) return null;
  if (!AVATAR_ALLOWED_TYPES.includes(file.type)) return null;

  const ext = file.name.split(".").pop() || "jpg";
  const path = `${userId}/avatar-${Date.now()}.${ext}`;

  const { error } = await supabase.storage
    .from("avatars")
    .upload(path, file, { cacheControl: "3600", upsert: true });

  if (error) return null;

  const {
    data: { publicUrl },
  } = supabase.storage.from("avatars").getPublicUrl(path);

  return publicUrl;
}

export async function completeSaasOnboarding(formData: FormData) {
  const supabase = await createClient();

  const {
    data: { user },
  } = await supabase.auth.getUser();
  if (!user) {
    return { error: "Non authentifié" };
  }

  const companyName = formData.get("companyName") as string;
  const description = formData.get("description") as string;
  const website = formData.get("website") as string;
  const industry = formData.get("industry") as string;
  const mediaPackUrl = formData.get("mediaPackUrl") as string | null;
  const country = formData.get("country") as string;
  const vatNumber = formData.get("vatNumber") as string | null;
  const isVatRegistered = formData.get("isVatRegistered") === "on";
  const avatarFile = formData.get("avatar") as File | null;

  let avatarUrl: string | null = null;
  if (avatarFile && avatarFile.size > 0) {
    const uploadedUrl = await uploadAvatarForUser(supabase, user.id, avatarFile);
    if (uploadedUrl) {
      avatarUrl = uploadedUrl;
    }
  }

  // Check if company already exists
  const { data: existingCompany } = await supabase
    .from("saas_companies")
    .select("id")
    .eq("profile_id", user.id)
    .single();

  if (existingCompany) {
    // Update existing company
    const { error } = await supabase
      .from("saas_companies")
      .update({
        company_name: companyName,
        description,
        website,
        industry,
        media_pack_url: mediaPackUrl,
        country: country || null,
        vat_number: vatNumber || null,
        is_vat_registered: isVatRegistered,
      })
      .eq("profile_id", user.id);

    if (error) {
      return { error: error.message };
    }
  } else {
    // Create new company
    // Note: API key will be auto-generated by database trigger
    const { error } = await supabase.from("saas_companies").insert({
      profile_id: user.id,
      company_name: companyName,
      description,
      website,
      industry,
      media_pack_url: mediaPackUrl,
      country: country || null,
      vat_number: vatNumber || null,
      is_vat_registered: isVatRegistered,
      // api_key is auto-generated by trigger, don't set it here
    });

    if (error) {
      return { error: error.message };
    }
  }

  // Mark onboarding as completed & optionally store avatar
  const profileUpdate: Record<string, unknown> = {
    onboarding_completed: true,
  };
  if (avatarUrl) {
    profileUpdate.avatar_url = avatarUrl;
  }

  const { error: profileError } = await supabase
    .from("profiles")
    .update(profileUpdate)
    .eq("id", user.id);

  if (profileError) {
    return { error: profileError.message };
  }

  revalidatePath("/dashboard");
  return { success: true };
}

export async function completeCreatorOnboarding(formData: FormData) {
  const supabase = await createClient();

  const {
    data: { user },
  } = await supabase.auth.getUser();
  if (!user) {
    return { error: "Non authentifié" };
  }

  const legalStatus = formData.get("legalStatus") as
    | "particulier"
    | "professionnel";
  const firstName = formData.get("firstName") as string;
  const lastName = formData.get("lastName") as string;
  const dateOfBirth = formData.get("dateOfBirth") as string;
  const streetAddress = formData.get("streetAddress") as string;
  const postalCode = formData.get("postalCode") as string;
  const city = formData.get("city") as string;
  const country = formData.get("country") as string;
  const linkedinUrl = normalizeLinkedInProfileUrl(
    formData.get("linkedinUrl") as string,
  );
  const followersCountRaw = formData.get("followersCount") as string | null;
  const followersCount =
    followersCountRaw && followersCountRaw.trim() !== ""
      ? Number.parseInt(followersCountRaw, 10) || 0
      : 0;
  const theme = formData.get("theme") as string | null;
  const bio = formData.get("bio") as string | null;
  const recentPostsLinkedin = formData.get("recentPostsLinkedin") as
    | string
    | null;
  const companyLegalName = formData.get("companyLegalName") as string | null;
  const companyRegistrationCountry = formData.get(
    "companyRegistrationCountry",
  ) as string | null;
  const companyTaxId = formData.get("companyTaxId") as string | null;
  const companyVatNumber = formData.get("companyVatNumber") as string | null;
  const companyRegisteredAddress = formData.get("companyRegisteredAddress") as
    | string
    | null;
  const avatarFile = formData.get("avatar") as File | null;

  if (legalStatus === "professionnel") {
    if (
      !companyLegalName ||
      !companyRegistrationCountry ||
      !companyTaxId ||
      !companyRegisteredAddress
    ) {
      return {
        error:
          "Informations d'entreprise manquantes. Merci de compléter tous les champs obligatoires.",
      };
    }
  }

  const updateData: Record<string, unknown> = {
    first_name: firstName,
    last_name: lastName,
    date_of_birth: dateOfBirth || null,
    street_address: streetAddress,
    postal_code: postalCode,
    city,
    country,
    linkedin_url: linkedinUrl,
    followers_count: followersCount,
    theme: theme || null,
    bio: bio || null,
    legal_status: legalStatus || "particulier",
    mandate_accepted_at: new Date().toISOString(),
  };

  if (legalStatus === "professionnel") {
    if (companyLegalName) {
      updateData.company_legal_name = companyLegalName;
    }
    if (companyRegistrationCountry) {
      updateData.company_registration_country = companyRegistrationCountry;
    }
    if (companyTaxId) {
      updateData.company_tax_id = companyTaxId;

      // For French companies, also map to legacy siret_number for compatibility
      if (companyRegistrationCountry === "FR") {
        const normalizedSiret = companyTaxId.replace(/\s+/g, "");
        updateData.siret_number = normalizedSiret;
      }
    }
    if (companyVatNumber) {
      updateData.company_vat_number = companyVatNumber;
    }
    if (companyRegisteredAddress) {
      updateData.company_registered_address = companyRegisteredAddress;
    }
  }

  if (recentPostsLinkedin) {
    updateData.recent_posts_linkedin = recentPostsLinkedin;
  }

  let avatarUrl: string | null = null;
  if (avatarFile && avatarFile.size > 0) {
    const uploadedUrl = await uploadAvatarForUser(supabase, user.id, avatarFile);
    if (uploadedUrl) {
      avatarUrl = uploadedUrl;
    }
  }

  // Check if creator profile already exists
  const { data: existingProfile } = await supabase
    .from("creator_profiles")
    .select("id")
    .eq("profile_id", user.id)
    .single();

  if (existingProfile) {
    const { error } = await supabase
      .from("creator_profiles")
      .update(updateData)
      .eq("profile_id", user.id);

    if (error) {
      return { error: error.message };
    }
  } else {
    const { error } = await supabase.from("creator_profiles").insert({
      profile_id: user.id,
      ...updateData,
    });

    if (error) {
      return { error: error.message };
    }
  }

  // Update profiles full_name, optional avatar & mark onboarding as completed
  const fullName = [firstName, lastName].filter(Boolean).join(" ");
  const profileUpdate: Record<string, unknown> = {
    onboarding_completed: true,
  };
  if (fullName) {
    profileUpdate.full_name = fullName;
  }
  if (avatarUrl) {
    profileUpdate.avatar_url = avatarUrl;
  }

  const { error: profileError } = await supabase
    .from("profiles")
    .update(profileUpdate)
    .eq("id", user.id);

  if (profileError) {
    return { error: profileError.message };
  }

  revalidatePath("/dashboard");
  return { success: true };
}

export async function uploadMediaPack(formData: FormData) {
  const supabase = await createClient();

  const {
    data: { user },
  } = await supabase.auth.getUser();
  if (!user) {
    return { error: "Non authentifié", url: null };
  }

  const file = formData.get("file") as File;
  if (!file) {
    return { error: "Aucun fichier fourni", url: null };
  }

  const fileExt = file.name.split(".").pop();
  const fileName = `${user.id}/media-pack-${Date.now()}.${fileExt}`;

  const { error, data } = await supabase.storage
    .from("media-packs")
    .upload(fileName, file, {
      cacheControl: "3600",
      upsert: true,
    });

  if (error) {
    return { error: error.message, url: null };
  }

  const {
    data: { publicUrl },
  } = supabase.storage.from("media-packs").getPublicUrl(fileName);

  return { success: true, url: publicUrl };
}

export async function getCurrentUserProfile() {
  const supabase = await createClient();

  const {
    data: { user },
  } = await supabase.auth.getUser();
  if (!user) {
    return null;
  }

  const { data: profile } = await supabase
    .from("profiles")
    .select("*")
    .eq("id", user.id)
    .single();

  return profile;
}

export async function signOut() {
  const supabase = await createClient();

  // Sign out from Supabase (clears session)
  await supabase.auth.signOut({ scope: "local" });

  // Return success - client will handle redirect
  return { success: true };
}
